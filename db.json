{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/tag-bg.jpg","path":"img/tag-bg.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.css","path":"css/hux-blog.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/home-bg-o.jpg","path":"img/home-bg-o.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"themes/huxblog/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528254933652},{"_id":"themes/huxblog/LICENSE","hash":"c48eaae47a703282e0ffe7b91d69366452046214","modified":1528254933652},{"_id":"themes/huxblog/_config.yml","hash":"30c43a39e3f2d05d634bdbd80a0f7d1c71230bfb","modified":1528254933652},{"_id":"source/404.md","hash":"8d0d831a77fe92a9e1530366ed90dec6d73d3aef","modified":1528254933626},{"_id":"themes/huxblog/languages_to_be_added/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1528254933653},{"_id":"themes/huxblog/languages_to_be_added/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1528254933653},{"_id":"themes/huxblog/languages_to_be_added/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1528254933654},{"_id":"themes/huxblog/languages_to_be_added/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1528254933654},{"_id":"themes/huxblog/languages_to_be_added/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1528254933654},{"_id":"themes/huxblog/languages_to_be_added/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1528254933655},{"_id":"themes/huxblog/languages_to_be_added/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1528254933655},{"_id":"themes/huxblog/languages_to_be_added/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1528254933656},{"_id":"themes/huxblog/languages_to_be_added/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1528254933656},{"_id":"themes/huxblog/layout/404.ejs","hash":"c9b488d74c21fe9f35f642a5d19a138099ddf8a8","modified":1528254933657},{"_id":"themes/huxblog/layout/about.ejs","hash":"0671d30031c2c64dc4d8ef8a3b7632ddce38c6d1","modified":1528254933659},{"_id":"themes/huxblog/layout/archive.ejs","hash":"6c3ed5d914379319efe835a4aa505abbc616c328","modified":1528254933660},{"_id":"themes/huxblog/layout/archives.ejs","hash":"75665b1537a56be6f227fd05ca21ae0e7af82e6e","modified":1528254933660},{"_id":"themes/huxblog/layout/index.ejs","hash":"fe992342f8f96f87521c78cc3a164ff01086aa9b","modified":1528254933660},{"_id":"themes/huxblog/layout/keynote.ejs","hash":"e177b9e4a159f40b512f4ae1bfd928be4ab60840","modified":1528254933661},{"_id":"themes/huxblog/layout/layout.ejs","hash":"fdd94ba0819440f3471e8fdf981e2d016841cfe6","modified":1528254933661},{"_id":"themes/huxblog/layout/page.ejs","hash":"53ba564cc61cb7778ece1e1abbdcbf5da21c9ba0","modified":1528254933662},{"_id":"themes/huxblog/layout/tags.ejs","hash":"3b5cb37b097895e6045b4dca91b8d4e39535f806","modified":1528254933662},{"_id":"themes/huxblog/layout/post.ejs","hash":"63a269d180a78e72e2ff5853ab579cf59ac943fa","modified":1528254933662},{"_id":"source/_posts/github页面连接域名.md","hash":"0461a341e3152f41198500edf08d29e17581bad7","modified":1528254933629},{"_id":"source/_posts/ZenCoding.md","hash":"c374bbbf0dd5de9083ac78582767dd5a305facdc","modified":1528254933627},{"_id":"source/_posts/js原型对象1.md","hash":"4c53e1f1a71cab13ed06b74b256dd382a1787d2d","modified":1528254933631},{"_id":"source/_posts/with.md","hash":"4668f17046786ea6395815c9a8995f6403f6f367","modified":1528254933632},{"_id":"source/_posts/js原型对象2.md","hash":"f8ec1e108bf7e31e3c85e104c2a9e5c685a6ad47","modified":1528254933631},{"_id":"source/about/index.md","hash":"c1e2be1bccff848ebb8bc2cffeabede5dd887196","modified":1528254933637},{"_id":"source/archives/index.md","hash":"a9f0b3e5433bcb0efff2faa5709ab44da3bfd146","modified":1528254933638},{"_id":"source/img/avatar.jpg","hash":"e972e60bffef64602d378aa52b27352f7e07dc8a","modified":1528254933643},{"_id":"source/img/favicon.ico","hash":"04684e0b8027ffd025f0a7a29b69b6ed54518634","modified":1528254933645},{"_id":"source/img/icon_wechat.png","hash":"7fdb00c9017236e05c1b3e6da38a2cc382fd69fa","modified":1528254933649},{"_id":"source/tags/index.md","hash":"bc710b5b8db6f01940957ce744a37fd564752c3b","modified":1528254933651},{"_id":"source/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1528254933650},{"_id":"themes/huxblog/layout/_partial/footer.ejs","hash":"6982457e5617eb945b50c2d742d84317567ae510","modified":1528254933657},{"_id":"themes/huxblog/layout/_partial/head.ejs","hash":"40d885fe82dc350f16698565440ddced47aeda3b","modified":1528254933658},{"_id":"themes/huxblog/layout/_partial/nav.ejs","hash":"e65bfec3d14a9eb9f1e09b592bb34023e6bf6e83","modified":1528254933658},{"_id":"themes/huxblog/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1528254933659},{"_id":"themes/huxblog/source/css/highlight.styl","hash":"831f8195f3577ba5bea374f2e24b90054d445055","modified":1528254933665},{"_id":"themes/huxblog/source/css/hux-blog.css","hash":"50e36726c65ec8c6428ccbc375bcab79f76f2bc8","modified":1528254933666},{"_id":"themes/huxblog/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1528254933666},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1528254933667},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1528254933669},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1528254933669},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1528254933670},{"_id":"themes/huxblog/source/js/bootstrap.min.js","hash":"313da686ebbe387064f2d1899c64ea562b81eb40","modified":1528254933671},{"_id":"themes/huxblog/source/js/hux-blog.min.js","hash":"ee99af17a1a69ac8d85a695fed0349ba202789ae","modified":1528254933672},{"_id":"themes/huxblog/source/js/hux-blog.js","hash":"3d3c93e42a9990b2a2e6df5a08e9816f9a221e0f","modified":1528254933672},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","hash":"448017ff32f75f444ed7985d10a21b3ad92ab100","modified":1528254933675},{"_id":"themes/huxblog/source/js/jquery.nav.js","hash":"bc6383fa2aa8f437978cf044a3b6f10a65114398","modified":1528254933675},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1528254933640},{"_id":"source/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1528254933647},{"_id":"themes/huxblog/source/css/bootstrap.min.css","hash":"d2333a926ae25bbd3056814f13fec0843468e49e","modified":1528254933665},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1528254933668},{"_id":"themes/huxblog/source/js/bootstrap.js","hash":"5d69034fb6eded2e5961ea54dd47129a88cd5182","modified":1528254933671},{"_id":"themes/huxblog/source/js/jquery.min.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1528254933675},{"_id":"source/_posts/ZenCoding/post-bg-js-module.jpg","hash":"4a43bfa6b69c79a6ef90bd852fe5756d241733cd","modified":1528254933628},{"_id":"source/_posts/with/post-bg-js-module.jpg","hash":"4a43bfa6b69c79a6ef90bd852fe5756d241733cd","modified":1528254933635},{"_id":"source/_posts/with/post-bg-unix-linux.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1528254933636},{"_id":"source/img/home-bg.jpg","hash":"a191201c3a98728e6ea66d6827df827ecfcc9d33","modified":1528254933648},{"_id":"themes/huxblog/source/css/bootstrap.css","hash":"d1a24afac31222d70b4e001e0361ef045aa42043","modified":1528254933664},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1528254933645},{"_id":"themes/huxblog/source/js/jquery.js","hash":"4bb763dc96da604aed08ac024a1a3f5de73eea39","modified":1528254933674},{"_id":"source/_posts/github页面连接域名/post-bg-2015.jpg","hash":"7118d1af8ac638dc55ee63d0b17e704811c6a37a","modified":1528254933631},{"_id":"source/_posts/with/post-bg-2015.jpg","hash":"7118d1af8ac638dc55ee63d0b17e704811c6a37a","modified":1528254933634},{"_id":"source/img/about-bg.jpg","hash":"b5814b2d10eb38dfda0072365567f3823bc34aba","modified":1528254933642}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-06-06T03:15:33.626Z","updated":"2018-06-06T03:15:33.626Z","path":"404.html","title":"","comments":1,"_id":"cji2oynqy0000scuu31n2suu7","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"","header-img":"img/about-bg.jpg","comments":1,"_content":"\n\n>写写代码，做做设计，看看产品。\n>世界那么大，多玩玩看看。\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"\"\nheader-img: \"img/about-bg.jpg\"\ncomments: true\n---\n\n\n>写写代码，做做设计，看看产品。\n>世界那么大，多玩玩看看。\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n","updated":"2018-06-06T03:15:33.637Z","path":"about/index.html","_id":"cji2oynrm0002scuuozzy9ed1","content":"<blockquote>\n<p>写写代码，做做设计，看看产品。<br>世界那么大，多玩玩看看。</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>写写代码，做做设计，看看产品。<br>世界那么大，多玩玩看看。</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n"},{"layout":"archives","title":"Archives","description":"Hey, this is Archives.","header-img":"img/tag-bg.jpg","_content":"","source":"archives/index.md","raw":"---\nlayout: \"archives\"\ntitle: \"Archives\"\ndescription: \"Hey, this is Archives.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2018-06-06T03:15:33.638Z","updated":"2018-06-06T03:15:33.638Z","path":"archives/index.html","comments":1,"_id":"cji2oynro0004scuuc1olfv9q","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/tag-bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2018-06-06T03:15:33.651Z","updated":"2018-06-06T03:15:33.651Z","path":"tags/index.html","comments":1,"_id":"cji2oynsg000qscuunwwr4l3y","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"github pages+阿里云域名绑定搭建个人博客","author":"古朋","header-img":"post-bg-2015.jpg","date":"2017-03-27T06:43:52.000Z","_content":"一直想整出一个个人博客出来玩玩，于是就查了些资料，发现在域名绑定个人博客这一块的资料比较杂，试了很多次才成功，所以写出篇文章供大家更方便的操作。\n\n## 1.获取github pages的ip地址\n\n打开你的电脑的命令行工具，ping你的github地址，忽略“/”后面的路径，比如我的github pages地址是[huyuee.github.io/blog](huyuee.github.io/blog)，那么我需要ping的地址就是huyuee.github.io，如下图：\n\n![image](https://cloud.githubusercontent.com/assets/12147318/24323059/f0607102-11aa-11e7-88ac-7043065de086.png)\n\n\n我得到了我的github pages的ip地址：151.101.100.133\n\n## 2.配置阿里云域名解析\n\n进入你的阿里云的解析域名列表，选择你想要解析的域名，点击后面的解析。如下图所示：\n\n![image](https://cloud.githubusercontent.com/assets/12147318/24323086/6dc683fc-11ab-11e7-854f-d0db969f43aa.png)\n\n\n然后点击添加解析，因为我的ip地址是151.101.100.133，所以我添加了两条解析记录。如下图所示：\n\n![image](https://cloud.githubusercontent.com/assets/12147318/24323066/01644df2-11ab-11e7-9f02-ca3a1544ded8.png)\n\n## 3.配置github pages的custom domain\n\n进入你的github pages的仓库，然后在设置里面将的你的域名的地址，添加到custom domain中，然后保存即可。如下图所示：\n\n\n![image](https://cloud.githubusercontent.com/assets/12147318/24323070/084fb192-11ab-11e7-8300-39e790b17cdf.png)\n\n\n设置到这个地方，你现在访问你的域名地址，比如我的是www.huyuee.com。就能看到你的github pages了！\n","source":"_posts/github页面连接域名.md","raw":"---\ntitle: github pages+阿里云域名绑定搭建个人博客\nauthor: 古朋\nheader-img: post-bg-2015.jpg\ntags:\n  - github\ndate: 2017-03-27 14:43:52\n---\n一直想整出一个个人博客出来玩玩，于是就查了些资料，发现在域名绑定个人博客这一块的资料比较杂，试了很多次才成功，所以写出篇文章供大家更方便的操作。\n\n## 1.获取github pages的ip地址\n\n打开你的电脑的命令行工具，ping你的github地址，忽略“/”后面的路径，比如我的github pages地址是[huyuee.github.io/blog](huyuee.github.io/blog)，那么我需要ping的地址就是huyuee.github.io，如下图：\n\n![image](https://cloud.githubusercontent.com/assets/12147318/24323059/f0607102-11aa-11e7-88ac-7043065de086.png)\n\n\n我得到了我的github pages的ip地址：151.101.100.133\n\n## 2.配置阿里云域名解析\n\n进入你的阿里云的解析域名列表，选择你想要解析的域名，点击后面的解析。如下图所示：\n\n![image](https://cloud.githubusercontent.com/assets/12147318/24323086/6dc683fc-11ab-11e7-854f-d0db969f43aa.png)\n\n\n然后点击添加解析，因为我的ip地址是151.101.100.133，所以我添加了两条解析记录。如下图所示：\n\n![image](https://cloud.githubusercontent.com/assets/12147318/24323066/01644df2-11ab-11e7-9f02-ca3a1544ded8.png)\n\n## 3.配置github pages的custom domain\n\n进入你的github pages的仓库，然后在设置里面将的你的域名的地址，添加到custom domain中，然后保存即可。如下图所示：\n\n\n![image](https://cloud.githubusercontent.com/assets/12147318/24323070/084fb192-11ab-11e7-8300-39e790b17cdf.png)\n\n\n设置到这个地方，你现在访问你的域名地址，比如我的是www.huyuee.com。就能看到你的github pages了！\n","slug":"github页面连接域名","published":1,"updated":"2018-06-06T03:15:33.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji2oynrj0001scuutgwmlgxj","content":"<p>一直想整出一个个人博客出来玩玩，于是就查了些资料，发现在域名绑定个人博客这一块的资料比较杂，试了很多次才成功，所以写出篇文章供大家更方便的操作。</p>\n<h2 id=\"1-获取github-pages的ip地址\"><a href=\"#1-获取github-pages的ip地址\" class=\"headerlink\" title=\"1.获取github pages的ip地址\"></a>1.获取github pages的ip地址</h2><p>打开你的电脑的命令行工具，ping你的github地址，忽略“/”后面的路径，比如我的github pages地址是<a href=\"huyuee.github.io/blog\">huyuee.github.io/blog</a>，那么我需要ping的地址就是huyuee.github.io，如下图：</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12147318/24323059/f0607102-11aa-11e7-88ac-7043065de086.png\" alt=\"image\"></p>\n<p>我得到了我的github pages的ip地址：151.101.100.133</p>\n<h2 id=\"2-配置阿里云域名解析\"><a href=\"#2-配置阿里云域名解析\" class=\"headerlink\" title=\"2.配置阿里云域名解析\"></a>2.配置阿里云域名解析</h2><p>进入你的阿里云的解析域名列表，选择你想要解析的域名，点击后面的解析。如下图所示：</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12147318/24323086/6dc683fc-11ab-11e7-854f-d0db969f43aa.png\" alt=\"image\"></p>\n<p>然后点击添加解析，因为我的ip地址是151.101.100.133，所以我添加了两条解析记录。如下图所示：</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12147318/24323066/01644df2-11ab-11e7-9f02-ca3a1544ded8.png\" alt=\"image\"></p>\n<h2 id=\"3-配置github-pages的custom-domain\"><a href=\"#3-配置github-pages的custom-domain\" class=\"headerlink\" title=\"3.配置github pages的custom domain\"></a>3.配置github pages的custom domain</h2><p>进入你的github pages的仓库，然后在设置里面将的你的域名的地址，添加到custom domain中，然后保存即可。如下图所示：</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12147318/24323070/084fb192-11ab-11e7-8300-39e790b17cdf.png\" alt=\"image\"></p>\n<p>设置到这个地方，你现在访问你的域名地址，比如我的是<a href=\"http://www.huyuee.com。就能看到你的github\" target=\"_blank\" rel=\"noopener\">www.huyuee.com。就能看到你的github</a> pages了！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一直想整出一个个人博客出来玩玩，于是就查了些资料，发现在域名绑定个人博客这一块的资料比较杂，试了很多次才成功，所以写出篇文章供大家更方便的操作。</p>\n<h2 id=\"1-获取github-pages的ip地址\"><a href=\"#1-获取github-pages的ip地址\" class=\"headerlink\" title=\"1.获取github pages的ip地址\"></a>1.获取github pages的ip地址</h2><p>打开你的电脑的命令行工具，ping你的github地址，忽略“/”后面的路径，比如我的github pages地址是<a href=\"huyuee.github.io/blog\">huyuee.github.io/blog</a>，那么我需要ping的地址就是huyuee.github.io，如下图：</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12147318/24323059/f0607102-11aa-11e7-88ac-7043065de086.png\" alt=\"image\"></p>\n<p>我得到了我的github pages的ip地址：151.101.100.133</p>\n<h2 id=\"2-配置阿里云域名解析\"><a href=\"#2-配置阿里云域名解析\" class=\"headerlink\" title=\"2.配置阿里云域名解析\"></a>2.配置阿里云域名解析</h2><p>进入你的阿里云的解析域名列表，选择你想要解析的域名，点击后面的解析。如下图所示：</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12147318/24323086/6dc683fc-11ab-11e7-854f-d0db969f43aa.png\" alt=\"image\"></p>\n<p>然后点击添加解析，因为我的ip地址是151.101.100.133，所以我添加了两条解析记录。如下图所示：</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12147318/24323066/01644df2-11ab-11e7-9f02-ca3a1544ded8.png\" alt=\"image\"></p>\n<h2 id=\"3-配置github-pages的custom-domain\"><a href=\"#3-配置github-pages的custom-domain\" class=\"headerlink\" title=\"3.配置github pages的custom domain\"></a>3.配置github pages的custom domain</h2><p>进入你的github pages的仓库，然后在设置里面将的你的域名的地址，添加到custom domain中，然后保存即可。如下图所示：</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/12147318/24323070/084fb192-11ab-11e7-8300-39e790b17cdf.png\" alt=\"image\"></p>\n<p>设置到这个地方，你现在访问你的域名地址，比如我的是<a href=\"http://www.huyuee.com。就能看到你的github\" target=\"_blank\" rel=\"noopener\">www.huyuee.com。就能看到你的github</a> pages了！</p>\n"},{"title":"js原型对象1","date":"2017-03-20T11:28:35.000Z","author":"古朋","_content":"## 为什么要写原型对象？\n\n原型，其实已经是前端知识中老生常谈的内容了。很多初学者和工作者其实都觉得这个概念其实跟你使用JavaScript没有太大的联系（因为我刚开始其实就是这样）。但是当你深入到代码中，一些架构中的时候，你就会发现巧妙的运用原型，能让你的代码写的既简洁又优美\n\n\n\n## 什么是原型对象\n\n无论什么时候，**只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性**，这个**属性**指向**函数**的**原型对象**\n\n举个栗子：\n\n```javascript\nfunction Person{\n}\nPerson.prototype.name = \"Nicholas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function(){\n\talert(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName(); //\"Nicholas\"\n\nvar person2 = new Person();\nperson2.sayName(); //\"Nicholas\"\n\nalert(person1.sayName == person2.sayName); //true\n```\n\n如下图图一所示，针对于上面的“栗子”，`Person`是一个函数，那么在 JavaScript中就会为这个函数创建一个prototype的属性，这个prototype属性指向该函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性指向该函数。\n\n\n![图一](http://upload-images.jianshu.io/upload_images/5099107-8d025db6f9977c21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n如上图图一所示：当调用构造函数创建一个新实例（person1和person2）后，该实例的内部将包含一个指针，指向构造函数的原型对象（Person Prototype）。\n\n\n\n## 原型对象的属性查找机制\n\n查找机制是这样的：**首先会先在实例上面搜索属性，如果找到了直接返回，否则就继续去原型上面寻找**。\n\n说个**形象一点的故事**，这样好理解一点。假设：实例就是你，原型就是你的父亲。你的有些东西是继承自你的父亲。比如你父亲在北京有一套价值1000W的别墅，他作为不动产留给了你。你自己也通过自己的努力，积攒了300W的积蓄。这个时候，你急需要用钱，你改怎么办？**首先你会看你自己有没有这个符合条件的积蓄，如果有，那么就用掉自己的积蓄，如果没有，那么就只能用父亲的房子作抵押给别人了。**\n\n先来个栗子：\n\n```javascript\nfunction Person(){\n}\n\nPerson.prototype.money = \"1000W\";\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.money = \"300W\";\nalert(person1.money); //\"300W\"----来自实例，是自己的钱\nalert(person2.money); //\"1000W\"----来自原型，是父亲的钱\n```\n\n从上面的例子我们能发现，当在alert()中访问person1.money时，他就会去实例上面搜索一个名为money的属性。这个属性在person1实例中找到了，直接返回。同理在person2的实例中寻找money属性时，没有找到，这时就需要继续去原型寻找，这个时候找到了，于是返回原型上面的值。\n\n\n\n## 如何判断属性值是来自实例还是原型？\n\n在了解完上面的知识之后，有的人就会问了，那我在写代码的时候，如何去判断属性值是来自实例的，还是来自原型对象上面的？就是说我想知道那个钱，到底我自己的积蓄，还是用的我父亲的房子。这个时候我就可以借助方法hasOwnProperty()，**当属性值是来自实例，也就是说是自己的钱，那么返回true，否则返回false**\n\n来段代码来看看：\n\n```javascript\nfunction Person(){\n}\n\nPerson.prototype.money = \"1000W\";\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.money = \"300W\";\nalert(person1.hasOwnProperty(money)); //true----来自实例，是自己的钱\nalert(person2.hasOwnProperty(money)); //false----来自原型，是父亲的钱\n```\n这一部分讲完了，可以前往观看[js原型对象（二)](http://www.jianshu.com/p/a14db8fc6509)\n","source":"_posts/js原型对象1.md","raw":"---\ntitle: js原型对象1\ndate: 2017-03-20 19:28:35\nauthor:     \"古朋\"\ntags:\n    - 前端开发\n    - JavaScript\n---\n## 为什么要写原型对象？\n\n原型，其实已经是前端知识中老生常谈的内容了。很多初学者和工作者其实都觉得这个概念其实跟你使用JavaScript没有太大的联系（因为我刚开始其实就是这样）。但是当你深入到代码中，一些架构中的时候，你就会发现巧妙的运用原型，能让你的代码写的既简洁又优美\n\n\n\n## 什么是原型对象\n\n无论什么时候，**只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性**，这个**属性**指向**函数**的**原型对象**\n\n举个栗子：\n\n```javascript\nfunction Person{\n}\nPerson.prototype.name = \"Nicholas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function(){\n\talert(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName(); //\"Nicholas\"\n\nvar person2 = new Person();\nperson2.sayName(); //\"Nicholas\"\n\nalert(person1.sayName == person2.sayName); //true\n```\n\n如下图图一所示，针对于上面的“栗子”，`Person`是一个函数，那么在 JavaScript中就会为这个函数创建一个prototype的属性，这个prototype属性指向该函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性指向该函数。\n\n\n![图一](http://upload-images.jianshu.io/upload_images/5099107-8d025db6f9977c21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n如上图图一所示：当调用构造函数创建一个新实例（person1和person2）后，该实例的内部将包含一个指针，指向构造函数的原型对象（Person Prototype）。\n\n\n\n## 原型对象的属性查找机制\n\n查找机制是这样的：**首先会先在实例上面搜索属性，如果找到了直接返回，否则就继续去原型上面寻找**。\n\n说个**形象一点的故事**，这样好理解一点。假设：实例就是你，原型就是你的父亲。你的有些东西是继承自你的父亲。比如你父亲在北京有一套价值1000W的别墅，他作为不动产留给了你。你自己也通过自己的努力，积攒了300W的积蓄。这个时候，你急需要用钱，你改怎么办？**首先你会看你自己有没有这个符合条件的积蓄，如果有，那么就用掉自己的积蓄，如果没有，那么就只能用父亲的房子作抵押给别人了。**\n\n先来个栗子：\n\n```javascript\nfunction Person(){\n}\n\nPerson.prototype.money = \"1000W\";\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.money = \"300W\";\nalert(person1.money); //\"300W\"----来自实例，是自己的钱\nalert(person2.money); //\"1000W\"----来自原型，是父亲的钱\n```\n\n从上面的例子我们能发现，当在alert()中访问person1.money时，他就会去实例上面搜索一个名为money的属性。这个属性在person1实例中找到了，直接返回。同理在person2的实例中寻找money属性时，没有找到，这时就需要继续去原型寻找，这个时候找到了，于是返回原型上面的值。\n\n\n\n## 如何判断属性值是来自实例还是原型？\n\n在了解完上面的知识之后，有的人就会问了，那我在写代码的时候，如何去判断属性值是来自实例的，还是来自原型对象上面的？就是说我想知道那个钱，到底我自己的积蓄，还是用的我父亲的房子。这个时候我就可以借助方法hasOwnProperty()，**当属性值是来自实例，也就是说是自己的钱，那么返回true，否则返回false**\n\n来段代码来看看：\n\n```javascript\nfunction Person(){\n}\n\nPerson.prototype.money = \"1000W\";\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.money = \"300W\";\nalert(person1.hasOwnProperty(money)); //true----来自实例，是自己的钱\nalert(person2.hasOwnProperty(money)); //false----来自原型，是父亲的钱\n```\n这一部分讲完了，可以前往观看[js原型对象（二)](http://www.jianshu.com/p/a14db8fc6509)\n","slug":"js原型对象1","published":1,"updated":"2018-06-06T03:15:33.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji2oynrn0003scuuwoihkro0","content":"<h2 id=\"为什么要写原型对象？\"><a href=\"#为什么要写原型对象？\" class=\"headerlink\" title=\"为什么要写原型对象？\"></a>为什么要写原型对象？</h2><p>原型，其实已经是前端知识中老生常谈的内容了。很多初学者和工作者其实都觉得这个概念其实跟你使用JavaScript没有太大的联系（因为我刚开始其实就是这样）。但是当你深入到代码中，一些架构中的时候，你就会发现巧妙的运用原型，能让你的代码写的既简洁又优美</p>\n<h2 id=\"什么是原型对象\"><a href=\"#什么是原型对象\" class=\"headerlink\" title=\"什么是原型对象\"></a>什么是原型对象</h2><p>无论什么时候，<strong>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性</strong>，这个<strong>属性</strong>指向<strong>函数</strong>的<strong>原型对象</strong></p>\n<p>举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">\"Nicholas\"</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">Person.prototype.job = <span class=\"string\">\"Software Engineer\"</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\talert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person1.sayName(); <span class=\"comment\">//\"Nicholas\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person2.sayName(); <span class=\"comment\">//\"Nicholas\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(person1.sayName == person2.sayName); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>如下图图一所示，针对于上面的“栗子”，<code>Person</code>是一个函数，那么在 JavaScript中就会为这个函数创建一个prototype的属性，这个prototype属性指向该函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性指向该函数。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5099107-8d025db6f9977c21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图一\"></p>\n<p>如上图图一所示：当调用构造函数创建一个新实例（person1和person2）后，该实例的内部将包含一个指针，指向构造函数的原型对象（Person Prototype）。</p>\n<h2 id=\"原型对象的属性查找机制\"><a href=\"#原型对象的属性查找机制\" class=\"headerlink\" title=\"原型对象的属性查找机制\"></a>原型对象的属性查找机制</h2><p>查找机制是这样的：<strong>首先会先在实例上面搜索属性，如果找到了直接返回，否则就继续去原型上面寻找</strong>。</p>\n<p>说个<strong>形象一点的故事</strong>，这样好理解一点。假设：实例就是你，原型就是你的父亲。你的有些东西是继承自你的父亲。比如你父亲在北京有一套价值1000W的别墅，他作为不动产留给了你。你自己也通过自己的努力，积攒了300W的积蓄。这个时候，你急需要用钱，你改怎么办？<strong>首先你会看你自己有没有这个符合条件的积蓄，如果有，那么就用掉自己的积蓄，如果没有，那么就只能用父亲的房子作抵押给别人了。</strong></p>\n<p>先来个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.money = <span class=\"string\">\"1000W\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">person1.money = <span class=\"string\">\"300W\"</span>;</span><br><span class=\"line\">alert(person1.money); <span class=\"comment\">//\"300W\"----来自实例，是自己的钱</span></span><br><span class=\"line\">alert(person2.money); <span class=\"comment\">//\"1000W\"----来自原型，是父亲的钱</span></span><br></pre></td></tr></table></figure>\n<p>从上面的例子我们能发现，当在alert()中访问person1.money时，他就会去实例上面搜索一个名为money的属性。这个属性在person1实例中找到了，直接返回。同理在person2的实例中寻找money属性时，没有找到，这时就需要继续去原型寻找，这个时候找到了，于是返回原型上面的值。</p>\n<h2 id=\"如何判断属性值是来自实例还是原型？\"><a href=\"#如何判断属性值是来自实例还是原型？\" class=\"headerlink\" title=\"如何判断属性值是来自实例还是原型？\"></a>如何判断属性值是来自实例还是原型？</h2><p>在了解完上面的知识之后，有的人就会问了，那我在写代码的时候，如何去判断属性值是来自实例的，还是来自原型对象上面的？就是说我想知道那个钱，到底我自己的积蓄，还是用的我父亲的房子。这个时候我就可以借助方法hasOwnProperty()，<strong>当属性值是来自实例，也就是说是自己的钱，那么返回true，否则返回false</strong></p>\n<p>来段代码来看看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.money = <span class=\"string\">\"1000W\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">person1.money = <span class=\"string\">\"300W\"</span>;</span><br><span class=\"line\">alert(person1.hasOwnProperty(money)); <span class=\"comment\">//true----来自实例，是自己的钱</span></span><br><span class=\"line\">alert(person2.hasOwnProperty(money)); <span class=\"comment\">//false----来自原型，是父亲的钱</span></span><br></pre></td></tr></table></figure>\n<p>这一部分讲完了，可以前往观看<a href=\"http://www.jianshu.com/p/a14db8fc6509\" target=\"_blank\" rel=\"noopener\">js原型对象（二)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么要写原型对象？\"><a href=\"#为什么要写原型对象？\" class=\"headerlink\" title=\"为什么要写原型对象？\"></a>为什么要写原型对象？</h2><p>原型，其实已经是前端知识中老生常谈的内容了。很多初学者和工作者其实都觉得这个概念其实跟你使用JavaScript没有太大的联系（因为我刚开始其实就是这样）。但是当你深入到代码中，一些架构中的时候，你就会发现巧妙的运用原型，能让你的代码写的既简洁又优美</p>\n<h2 id=\"什么是原型对象\"><a href=\"#什么是原型对象\" class=\"headerlink\" title=\"什么是原型对象\"></a>什么是原型对象</h2><p>无论什么时候，<strong>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性</strong>，这个<strong>属性</strong>指向<strong>函数</strong>的<strong>原型对象</strong></p>\n<p>举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">\"Nicholas\"</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">Person.prototype.job = <span class=\"string\">\"Software Engineer\"</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\talert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person1.sayName(); <span class=\"comment\">//\"Nicholas\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person2.sayName(); <span class=\"comment\">//\"Nicholas\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(person1.sayName == person2.sayName); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>如下图图一所示，针对于上面的“栗子”，<code>Person</code>是一个函数，那么在 JavaScript中就会为这个函数创建一个prototype的属性，这个prototype属性指向该函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性指向该函数。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/5099107-8d025db6f9977c21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图一\"></p>\n<p>如上图图一所示：当调用构造函数创建一个新实例（person1和person2）后，该实例的内部将包含一个指针，指向构造函数的原型对象（Person Prototype）。</p>\n<h2 id=\"原型对象的属性查找机制\"><a href=\"#原型对象的属性查找机制\" class=\"headerlink\" title=\"原型对象的属性查找机制\"></a>原型对象的属性查找机制</h2><p>查找机制是这样的：<strong>首先会先在实例上面搜索属性，如果找到了直接返回，否则就继续去原型上面寻找</strong>。</p>\n<p>说个<strong>形象一点的故事</strong>，这样好理解一点。假设：实例就是你，原型就是你的父亲。你的有些东西是继承自你的父亲。比如你父亲在北京有一套价值1000W的别墅，他作为不动产留给了你。你自己也通过自己的努力，积攒了300W的积蓄。这个时候，你急需要用钱，你改怎么办？<strong>首先你会看你自己有没有这个符合条件的积蓄，如果有，那么就用掉自己的积蓄，如果没有，那么就只能用父亲的房子作抵押给别人了。</strong></p>\n<p>先来个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.money = <span class=\"string\">\"1000W\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">person1.money = <span class=\"string\">\"300W\"</span>;</span><br><span class=\"line\">alert(person1.money); <span class=\"comment\">//\"300W\"----来自实例，是自己的钱</span></span><br><span class=\"line\">alert(person2.money); <span class=\"comment\">//\"1000W\"----来自原型，是父亲的钱</span></span><br></pre></td></tr></table></figure>\n<p>从上面的例子我们能发现，当在alert()中访问person1.money时，他就会去实例上面搜索一个名为money的属性。这个属性在person1实例中找到了，直接返回。同理在person2的实例中寻找money属性时，没有找到，这时就需要继续去原型寻找，这个时候找到了，于是返回原型上面的值。</p>\n<h2 id=\"如何判断属性值是来自实例还是原型？\"><a href=\"#如何判断属性值是来自实例还是原型？\" class=\"headerlink\" title=\"如何判断属性值是来自实例还是原型？\"></a>如何判断属性值是来自实例还是原型？</h2><p>在了解完上面的知识之后，有的人就会问了，那我在写代码的时候，如何去判断属性值是来自实例的，还是来自原型对象上面的？就是说我想知道那个钱，到底我自己的积蓄，还是用的我父亲的房子。这个时候我就可以借助方法hasOwnProperty()，<strong>当属性值是来自实例，也就是说是自己的钱，那么返回true，否则返回false</strong></p>\n<p>来段代码来看看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.money = <span class=\"string\">\"1000W\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\">person1.money = <span class=\"string\">\"300W\"</span>;</span><br><span class=\"line\">alert(person1.hasOwnProperty(money)); <span class=\"comment\">//true----来自实例，是自己的钱</span></span><br><span class=\"line\">alert(person2.hasOwnProperty(money)); <span class=\"comment\">//false----来自原型，是父亲的钱</span></span><br></pre></td></tr></table></figure>\n<p>这一部分讲完了，可以前往观看<a href=\"http://www.jianshu.com/p/a14db8fc6509\" target=\"_blank\" rel=\"noopener\">js原型对象（二)</a></p>\n"},{"title":"Zen Coding--如何快速地书写HTML代码","author":"古朋","header-img":"post-bg-js-module.jpg","date":"2017-04-07T14:58:00.000Z","_content":"\n# 描述\n\n在本文中我们将展示一种新的使用仿CSS选择器的语法来快速开发HTML的方法。\n\n我使用的是[atom编辑器](https://atom.io/)——由 Github 打造的编程开发利器，他自带这个解析功能。当然其他的如sublime，webstorm等都会自带这个功能，或者使用相关的插件即可。\n\n你在写HTML代码(包括所有标签、属性、引用、大括号等)上花费多少时间？如果你的编辑器有代码提示功能，你编写的时候就会容易些，但即便如此你还是要手动敲入很多代码。\n\n\n\n比如，你这么写，按下`tab`键：\n\n```html\ndiv#content>h1+p\n```\n\n然后就看到了这样的输出：\n\n```html\n<div id=\"content\">  \n<h1></h1>  \n<p></p>  \n</div>\n```\n\n\n\n# 用法\n\n这里是一个支持的属性和操作符的列表：\n\n- E\n\n  元素名称(`div`, `p`等);\n\n- E#id\n  使用id的元素(`div#content`, `p#intro`, `span#error`);\n\n- E.class\n  使用类的元素(`div.header`, `p.error.critial`). 你也可以联合使用class和idID: `div#content.column.width`;\n\n- E>N\n  子代元素(`div>p`, `div#footer>p>span`);\n\n- E+N\n  兄弟元素(`h1+p`, `div#header+div#content+div#footer`);\n\n- E*N\n  元素倍增(`ul#nav>li*5>a`);\n\n- E$*N\n\n  条目编号 (`ul#nav>li.item-$*5`);\n\n\n\n# 示例\n\n这里就针对于倍增和条目编号来举例子吧。\n\n\n\n## 元素倍增\n\n比如你写个`li*4>a`，就会生成以下HTML代码：\n\n```html\n<li><a href=\"\"></a></li>  \n<li><a href=\"\"></a></li>  \n<li><a href=\"\"></a></li>  \n<li><a href=\"\"></a></li>  \n```\n\n\n\n## 条目编号\n\n假设你想生成class为`item1`、`item2`和`item3`的3个`<div>`元素。你可以写成这样的缩写，`div.item$*3`:\n\n```html\n<div class=\"item1\"></div>  \n<div class=\"item2\"></div>  \n<div class=\"item3\"></div>\n```\n\n\n\n简单吧，赶紧打开你的编辑器操练起来吧！\n","source":"_posts/ZenCoding.md","raw":"---\ntitle: Zen Coding--如何快速地书写HTML代码\nauthor: 古朋\nheader-img: post-bg-js-module.jpg\ntags:\n  - 前端开发\n  - JavaScript\ndate: 2017-04-07 22:58:00\n---\n\n# 描述\n\n在本文中我们将展示一种新的使用仿CSS选择器的语法来快速开发HTML的方法。\n\n我使用的是[atom编辑器](https://atom.io/)——由 Github 打造的编程开发利器，他自带这个解析功能。当然其他的如sublime，webstorm等都会自带这个功能，或者使用相关的插件即可。\n\n你在写HTML代码(包括所有标签、属性、引用、大括号等)上花费多少时间？如果你的编辑器有代码提示功能，你编写的时候就会容易些，但即便如此你还是要手动敲入很多代码。\n\n\n\n比如，你这么写，按下`tab`键：\n\n```html\ndiv#content>h1+p\n```\n\n然后就看到了这样的输出：\n\n```html\n<div id=\"content\">  \n<h1></h1>  \n<p></p>  \n</div>\n```\n\n\n\n# 用法\n\n这里是一个支持的属性和操作符的列表：\n\n- E\n\n  元素名称(`div`, `p`等);\n\n- E#id\n  使用id的元素(`div#content`, `p#intro`, `span#error`);\n\n- E.class\n  使用类的元素(`div.header`, `p.error.critial`). 你也可以联合使用class和idID: `div#content.column.width`;\n\n- E>N\n  子代元素(`div>p`, `div#footer>p>span`);\n\n- E+N\n  兄弟元素(`h1+p`, `div#header+div#content+div#footer`);\n\n- E*N\n  元素倍增(`ul#nav>li*5>a`);\n\n- E$*N\n\n  条目编号 (`ul#nav>li.item-$*5`);\n\n\n\n# 示例\n\n这里就针对于倍增和条目编号来举例子吧。\n\n\n\n## 元素倍增\n\n比如你写个`li*4>a`，就会生成以下HTML代码：\n\n```html\n<li><a href=\"\"></a></li>  \n<li><a href=\"\"></a></li>  \n<li><a href=\"\"></a></li>  \n<li><a href=\"\"></a></li>  \n```\n\n\n\n## 条目编号\n\n假设你想生成class为`item1`、`item2`和`item3`的3个`<div>`元素。你可以写成这样的缩写，`div.item$*3`:\n\n```html\n<div class=\"item1\"></div>  \n<div class=\"item2\"></div>  \n<div class=\"item3\"></div>\n```\n\n\n\n简单吧，赶紧打开你的编辑器操练起来吧！\n","slug":"ZenCoding","published":1,"updated":"2018-06-06T03:15:33.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji2oynrq0006scuuc09yhl5t","content":"<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>在本文中我们将展示一种新的使用仿CSS选择器的语法来快速开发HTML的方法。</p>\n<p>我使用的是<a href=\"https://atom.io/\" target=\"_blank\" rel=\"noopener\">atom编辑器</a>——由 Github 打造的编程开发利器，他自带这个解析功能。当然其他的如sublime，webstorm等都会自带这个功能，或者使用相关的插件即可。</p>\n<p>你在写HTML代码(包括所有标签、属性、引用、大括号等)上花费多少时间？如果你的编辑器有代码提示功能，你编写的时候就会容易些，但即便如此你还是要手动敲入很多代码。</p>\n<p>比如，你这么写，按下<code>tab</code>键：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div#content&gt;h1+p</span><br></pre></td></tr></table></figure>\n<p>然后就看到了这样的输出：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><p>这里是一个支持的属性和操作符的列表：</p>\n<ul>\n<li><p>E</p>\n<p>元素名称(<code>div</code>, <code>p</code>等);</p>\n</li>\n<li><p>E#id<br>使用id的元素(<code>div#content</code>, <code>p#intro</code>, <code>span#error</code>);</p>\n</li>\n<li><p>E.class<br>使用类的元素(<code>div.header</code>, <code>p.error.critial</code>). 你也可以联合使用class和idID: <code>div#content.column.width</code>;</p>\n</li>\n<li><p>E&gt;N<br>子代元素(<code>div&gt;p</code>, <code>div#footer&gt;p&gt;span</code>);</p>\n</li>\n<li><p>E+N<br>兄弟元素(<code>h1+p</code>, <code>div#header+div#content+div#footer</code>);</p>\n</li>\n<li><p>E<em>N<br>元素倍增(`ul#nav&gt;li</em>5&gt;a`);</p>\n</li>\n<li><p>E$*N</p>\n<p>条目编号 (<code>ul#nav&gt;li.item-$*5</code>);</p>\n</li>\n</ul>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><p>这里就针对于倍增和条目编号来举例子吧。</p>\n<h2 id=\"元素倍增\"><a href=\"#元素倍增\" class=\"headerlink\" title=\"元素倍增\"></a>元素倍增</h2><p>比如你写个<code>li*4&gt;a</code>，就会生成以下HTML代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"条目编号\"><a href=\"#条目编号\" class=\"headerlink\" title=\"条目编号\"></a>条目编号</h2><p>假设你想生成class为<code>item1</code>、<code>item2</code>和<code>item3</code>的3个<code>&lt;div&gt;</code>元素。你可以写成这样的缩写，<code>div.item$*3</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item3\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>简单吧，赶紧打开你的编辑器操练起来吧！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h1><p>在本文中我们将展示一种新的使用仿CSS选择器的语法来快速开发HTML的方法。</p>\n<p>我使用的是<a href=\"https://atom.io/\" target=\"_blank\" rel=\"noopener\">atom编辑器</a>——由 Github 打造的编程开发利器，他自带这个解析功能。当然其他的如sublime，webstorm等都会自带这个功能，或者使用相关的插件即可。</p>\n<p>你在写HTML代码(包括所有标签、属性、引用、大括号等)上花费多少时间？如果你的编辑器有代码提示功能，你编写的时候就会容易些，但即便如此你还是要手动敲入很多代码。</p>\n<p>比如，你这么写，按下<code>tab</code>键：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div#content&gt;h1+p</span><br></pre></td></tr></table></figure>\n<p>然后就看到了这样的输出：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><p>这里是一个支持的属性和操作符的列表：</p>\n<ul>\n<li><p>E</p>\n<p>元素名称(<code>div</code>, <code>p</code>等);</p>\n</li>\n<li><p>E#id<br>使用id的元素(<code>div#content</code>, <code>p#intro</code>, <code>span#error</code>);</p>\n</li>\n<li><p>E.class<br>使用类的元素(<code>div.header</code>, <code>p.error.critial</code>). 你也可以联合使用class和idID: <code>div#content.column.width</code>;</p>\n</li>\n<li><p>E&gt;N<br>子代元素(<code>div&gt;p</code>, <code>div#footer&gt;p&gt;span</code>);</p>\n</li>\n<li><p>E+N<br>兄弟元素(<code>h1+p</code>, <code>div#header+div#content+div#footer</code>);</p>\n</li>\n<li><p>E<em>N<br>元素倍增(`ul#nav&gt;li</em>5&gt;a`);</p>\n</li>\n<li><p>E$*N</p>\n<p>条目编号 (<code>ul#nav&gt;li.item-$*5</code>);</p>\n</li>\n</ul>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><p>这里就针对于倍增和条目编号来举例子吧。</p>\n<h2 id=\"元素倍增\"><a href=\"#元素倍增\" class=\"headerlink\" title=\"元素倍增\"></a>元素倍增</h2><p>比如你写个<code>li*4&gt;a</code>，就会生成以下HTML代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"条目编号\"><a href=\"#条目编号\" class=\"headerlink\" title=\"条目编号\"></a>条目编号</h2><p>假设你想生成class为<code>item1</code>、<code>item2</code>和<code>item3</code>的3个<code>&lt;div&gt;</code>元素。你可以写成这样的缩写，<code>div.item$*3</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item3\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>简单吧，赶紧打开你的编辑器操练起来吧！</p>\n"},{"title":"js原型对象2","date":"2017-03-21T11:28:43.000Z","author":"古朋","_content":"在看下面的内容之前，建议先看我写的[js原型对象（一)](http://www.jianshu.com/p/541051e2ffda)\n\n## 更简单的原型语法\n\n在看了前面栗子之后，你们可能注意到了，每添加一个属性和方法就要敲一遍Person.prototype。为了使代码简洁美观，最常见的做法是用一个包含所有属性的方法的对象字面量来重写整个原型对象。\n\n来看个栗子：\n\n```javascript\nfunction Person(){\n}\nPerson.prototype = {\n  name : \"Lee\",\n  age : 20\n}\n```\n\n但是上面的这种更简单的写法有几个问题：\n\n**1.上面的写法本质上完全重写了默认的prototype对象，因此使得原型中的constructor属性不再指向Person了**。这种情况的时候如果constructor属性很重要，可以像下面这样特意将他设置回适当的值\n\n```javascript\nfunction Person(){\n}\nPerson.prototype = {\n  constructor : Person,//设置回适当的值\n  name : \"Lee\",\n  age : 20\n}\n```\n\n**2.上面的写法在重写了默认的prototype对象，切断了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的仍然是最初的原型**。\n\n下面两个栗子来对比这个问题：\n\n1）没有重写原型对象的栗子：\n\n```javascript\nfunction Person(){\n}\nvar lee = new Person();\nPerson.prototype.name = 'Lee';\nalert(lee.name);//'Lee'\n```\n\n2）重写原型对象的栗子\n\n```javascript\nfunction Person(){\n}\nvar lee = new Person();\nPerson.prototype = {\n  constructor : Person,//设置回适当的值\n  name : \"Lee\",\n  age : 20\n}\nalert(lee.name);//undefined\n```\n\n\n\n## 原型对象的问题\n\n原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也说得过去，毕竟（上面一篇文章中所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，**对于包含引用类型值的属性就有问题了**。\n\n举个栗子：\n\n```javascript\nfunction Person(){\n}\n\nPerson.prototype = {\n  constructor : Person,//设置回适当的值\n  name : \"Lee\",\n  age : 20,\n  friends : [\"Wang\",\"Tang\"]\n}\nvar p1 = new Person();\nvar p2 = new Person();\n\np1.friends.push(\"Zhang\");\n\nalert(p1.friends);//\"Wang,Tang,Zhang\"\nalert(p2.friends);//\"Wang,Tang,Zhang\"\nalert(p1.friends === p2.friends);//true\n```\n\n在上面的例子中，Person.prototype对象有一个名为friends的属性，该属性包含一个字符串数组。这个属性就是包含引用类型值属性。因为该属性是保存的对这个数组的引用，相当于就是说所有的实例都是公用的同一个这个数组，只要一个人对这个数组进行了修改，其他实例就都会改变。\n","source":"_posts/js原型对象2.md","raw":"---\ntitle: js原型对象2\ndate: 2017-03-21 19:28:43\nauthor:     \"古朋\"\ntags:\n    - 前端开发\n    - JavaScript\n---\n在看下面的内容之前，建议先看我写的[js原型对象（一)](http://www.jianshu.com/p/541051e2ffda)\n\n## 更简单的原型语法\n\n在看了前面栗子之后，你们可能注意到了，每添加一个属性和方法就要敲一遍Person.prototype。为了使代码简洁美观，最常见的做法是用一个包含所有属性的方法的对象字面量来重写整个原型对象。\n\n来看个栗子：\n\n```javascript\nfunction Person(){\n}\nPerson.prototype = {\n  name : \"Lee\",\n  age : 20\n}\n```\n\n但是上面的这种更简单的写法有几个问题：\n\n**1.上面的写法本质上完全重写了默认的prototype对象，因此使得原型中的constructor属性不再指向Person了**。这种情况的时候如果constructor属性很重要，可以像下面这样特意将他设置回适当的值\n\n```javascript\nfunction Person(){\n}\nPerson.prototype = {\n  constructor : Person,//设置回适当的值\n  name : \"Lee\",\n  age : 20\n}\n```\n\n**2.上面的写法在重写了默认的prototype对象，切断了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的仍然是最初的原型**。\n\n下面两个栗子来对比这个问题：\n\n1）没有重写原型对象的栗子：\n\n```javascript\nfunction Person(){\n}\nvar lee = new Person();\nPerson.prototype.name = 'Lee';\nalert(lee.name);//'Lee'\n```\n\n2）重写原型对象的栗子\n\n```javascript\nfunction Person(){\n}\nvar lee = new Person();\nPerson.prototype = {\n  constructor : Person,//设置回适当的值\n  name : \"Lee\",\n  age : 20\n}\nalert(lee.name);//undefined\n```\n\n\n\n## 原型对象的问题\n\n原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也说得过去，毕竟（上面一篇文章中所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，**对于包含引用类型值的属性就有问题了**。\n\n举个栗子：\n\n```javascript\nfunction Person(){\n}\n\nPerson.prototype = {\n  constructor : Person,//设置回适当的值\n  name : \"Lee\",\n  age : 20,\n  friends : [\"Wang\",\"Tang\"]\n}\nvar p1 = new Person();\nvar p2 = new Person();\n\np1.friends.push(\"Zhang\");\n\nalert(p1.friends);//\"Wang,Tang,Zhang\"\nalert(p2.friends);//\"Wang,Tang,Zhang\"\nalert(p1.friends === p2.friends);//true\n```\n\n在上面的例子中，Person.prototype对象有一个名为friends的属性，该属性包含一个字符串数组。这个属性就是包含引用类型值属性。因为该属性是保存的对这个数组的引用，相当于就是说所有的实例都是公用的同一个这个数组，只要一个人对这个数组进行了修改，其他实例就都会改变。\n","slug":"js原型对象2","published":1,"updated":"2018-06-06T03:15:33.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji2oynrs0007scuul5ndnd7s","content":"<p>在看下面的内容之前，建议先看我写的<a href=\"http://www.jianshu.com/p/541051e2ffda\" target=\"_blank\" rel=\"noopener\">js原型对象（一)</a></p>\n<h2 id=\"更简单的原型语法\"><a href=\"#更简单的原型语法\" class=\"headerlink\" title=\"更简单的原型语法\"></a>更简单的原型语法</h2><p>在看了前面栗子之后，你们可能注意到了，每添加一个属性和方法就要敲一遍Person.prototype。为了使代码简洁美观，最常见的做法是用一个包含所有属性的方法的对象字面量来重写整个原型对象。</p>\n<p>来看个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">\"Lee\"</span>,</span><br><span class=\"line\">  age : <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是上面的这种更简单的写法有几个问题：</p>\n<p><strong>1.上面的写法本质上完全重写了默认的prototype对象，因此使得原型中的constructor属性不再指向Person了</strong>。这种情况的时候如果constructor属性很重要，可以像下面这样特意将他设置回适当的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> : Person,//设置回适当的值</span><br><span class=\"line\">  name : \"Lee\",</span><br><span class=\"line\">  age : 20</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2.上面的写法在重写了默认的prototype对象，切断了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的仍然是最初的原型</strong>。</p>\n<p>下面两个栗子来对比这个问题：</p>\n<p>1）没有重写原型对象的栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> lee = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">'Lee'</span>;</span><br><span class=\"line\">alert(lee.name);<span class=\"comment\">//'Lee'</span></span><br></pre></td></tr></table></figure>\n<p>2）重写原型对象的栗子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> lee = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> : Person,//设置回适当的值</span><br><span class=\"line\">  name : \"Lee\",</span><br><span class=\"line\">  age : 20</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(lee.name);//undefined</span><br></pre></td></tr></table></figure>\n<h2 id=\"原型对象的问题\"><a href=\"#原型对象的问题\" class=\"headerlink\" title=\"原型对象的问题\"></a>原型对象的问题</h2><p>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也说得过去，毕竟（上面一篇文章中所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，<strong>对于包含引用类型值的属性就有问题了</strong>。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> : Person,//设置回适当的值</span><br><span class=\"line\">  name : \"Lee\",</span><br><span class=\"line\">  age : 20,</span><br><span class=\"line\">  friends : [\"Wang\",\"Tang\"]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var p1 = new Person();</span><br><span class=\"line\">var p2 = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">p1.friends.push(\"Zhang\");</span><br><span class=\"line\"></span><br><span class=\"line\">alert(p1.friends);//\"Wang,Tang,Zhang\"</span><br><span class=\"line\">alert(p2.friends);//\"Wang,Tang,Zhang\"</span><br><span class=\"line\">alert(p1.friends === p2.friends);//true</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，Person.prototype对象有一个名为friends的属性，该属性包含一个字符串数组。这个属性就是包含引用类型值属性。因为该属性是保存的对这个数组的引用，相当于就是说所有的实例都是公用的同一个这个数组，只要一个人对这个数组进行了修改，其他实例就都会改变。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在看下面的内容之前，建议先看我写的<a href=\"http://www.jianshu.com/p/541051e2ffda\" target=\"_blank\" rel=\"noopener\">js原型对象（一)</a></p>\n<h2 id=\"更简单的原型语法\"><a href=\"#更简单的原型语法\" class=\"headerlink\" title=\"更简单的原型语法\"></a>更简单的原型语法</h2><p>在看了前面栗子之后，你们可能注意到了，每添加一个属性和方法就要敲一遍Person.prototype。为了使代码简洁美观，最常见的做法是用一个包含所有属性的方法的对象字面量来重写整个原型对象。</p>\n<p>来看个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">\"Lee\"</span>,</span><br><span class=\"line\">  age : <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是上面的这种更简单的写法有几个问题：</p>\n<p><strong>1.上面的写法本质上完全重写了默认的prototype对象，因此使得原型中的constructor属性不再指向Person了</strong>。这种情况的时候如果constructor属性很重要，可以像下面这样特意将他设置回适当的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> : Person,//设置回适当的值</span><br><span class=\"line\">  name : \"Lee\",</span><br><span class=\"line\">  age : 20</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2.上面的写法在重写了默认的prototype对象，切断了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的仍然是最初的原型</strong>。</p>\n<p>下面两个栗子来对比这个问题：</p>\n<p>1）没有重写原型对象的栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> lee = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">'Lee'</span>;</span><br><span class=\"line\">alert(lee.name);<span class=\"comment\">//'Lee'</span></span><br></pre></td></tr></table></figure>\n<p>2）重写原型对象的栗子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> lee = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> : Person,//设置回适当的值</span><br><span class=\"line\">  name : \"Lee\",</span><br><span class=\"line\">  age : 20</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(lee.name);//undefined</span><br></pre></td></tr></table></figure>\n<h2 id=\"原型对象的问题\"><a href=\"#原型对象的问题\" class=\"headerlink\" title=\"原型对象的问题\"></a>原型对象的问题</h2><p>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也说得过去，毕竟（上面一篇文章中所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，<strong>对于包含引用类型值的属性就有问题了</strong>。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> : Person,//设置回适当的值</span><br><span class=\"line\">  name : \"Lee\",</span><br><span class=\"line\">  age : 20,</span><br><span class=\"line\">  friends : [\"Wang\",\"Tang\"]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var p1 = new Person();</span><br><span class=\"line\">var p2 = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">p1.friends.push(\"Zhang\");</span><br><span class=\"line\"></span><br><span class=\"line\">alert(p1.friends);//\"Wang,Tang,Zhang\"</span><br><span class=\"line\">alert(p2.friends);//\"Wang,Tang,Zhang\"</span><br><span class=\"line\">alert(p1.friends === p2.friends);//true</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，Person.prototype对象有一个名为friends的属性，该属性包含一个字符串数组。这个属性就是包含引用类型值属性。因为该属性是保存的对这个数组的引用，相当于就是说所有的实例都是公用的同一个这个数组，只要一个人对这个数组进行了修改，其他实例就都会改变。</p>\n"},{"title":"with语句详解","date":"2017-03-15T15:21:00.000Z","author":"古朋","header-img":"post-bg-2015.jpg","_content":"\nwith这种语法现如今应该已经无人问津了，但是还是想来说说这个在JavaScript中的用法和缺点\n\n## 介绍\n\nwith语句的作用是将代码的作用域设置到一个特定的对象中。\n\n利：with语句可以在不造成性能损失的情况下，减少变量的长度。很多情况下，也可以不使用with语句，而是使用一个临时变量来保存指针，来达到同样的效果。\n\n弊：with语句使得程序在查找该语句块中的所有的变量值时，都是先在该with语句指定的对象下面先寻找一遍，然后再去外面的作用域去寻找。所以尽量不要在该语句块中去使用一些不属于该对象中的变量\n\n## 用法\n\n```javascript\nvar x = {\n  name : \"古朋\",\n  nick_name : \"gupeng\"\n};\nwith(x){\n  console.log(name+'的小名是'+nick_name);\n}\n```\n可以替换为:\n\n```\nvar x = {\n  name : \"古朋\",\n  nick_name : \"gupeng\"\n};\n/*\n *这里将x对象赋值到当前局部变量中，减少不必要的指针路径解析运算\n *一般用于在在方法中将this对象局部化，比如：var this_ = this;\n */\nvar x_ = x;\nconsole.log(x_.name+'的小名是'+x_nick_name);\n```\n","source":"_posts/with.md","raw":"---\ntitle:      \"with语句详解\"\ndate:       2017-03-15 23:21:00\nauthor:     \"古朋\"\nheader-img: \"post-bg-2015.jpg\"\ntags:\n    - 前端开发\n    - JavaScript\n---\n\nwith这种语法现如今应该已经无人问津了，但是还是想来说说这个在JavaScript中的用法和缺点\n\n## 介绍\n\nwith语句的作用是将代码的作用域设置到一个特定的对象中。\n\n利：with语句可以在不造成性能损失的情况下，减少变量的长度。很多情况下，也可以不使用with语句，而是使用一个临时变量来保存指针，来达到同样的效果。\n\n弊：with语句使得程序在查找该语句块中的所有的变量值时，都是先在该with语句指定的对象下面先寻找一遍，然后再去外面的作用域去寻找。所以尽量不要在该语句块中去使用一些不属于该对象中的变量\n\n## 用法\n\n```javascript\nvar x = {\n  name : \"古朋\",\n  nick_name : \"gupeng\"\n};\nwith(x){\n  console.log(name+'的小名是'+nick_name);\n}\n```\n可以替换为:\n\n```\nvar x = {\n  name : \"古朋\",\n  nick_name : \"gupeng\"\n};\n/*\n *这里将x对象赋值到当前局部变量中，减少不必要的指针路径解析运算\n *一般用于在在方法中将this对象局部化，比如：var this_ = this;\n */\nvar x_ = x;\nconsole.log(x_.name+'的小名是'+x_nick_name);\n```\n","slug":"with","published":1,"updated":"2018-06-06T03:15:33.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji2oynrt0008scuusk4t3ivm","content":"<p>with这种语法现如今应该已经无人问津了，但是还是想来说说这个在JavaScript中的用法和缺点</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>with语句的作用是将代码的作用域设置到一个特定的对象中。</p>\n<p>利：with语句可以在不造成性能损失的情况下，减少变量的长度。很多情况下，也可以不使用with语句，而是使用一个临时变量来保存指针，来达到同样的效果。</p>\n<p>弊：with语句使得程序在查找该语句块中的所有的变量值时，都是先在该with语句指定的对象下面先寻找一遍，然后再去外面的作用域去寻找。所以尽量不要在该语句块中去使用一些不属于该对象中的变量</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">\"古朋\"</span>,</span><br><span class=\"line\">  nick_name : <span class=\"string\">\"gupeng\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">with</span>(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name+<span class=\"string\">'的小名是'</span>+nick_name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以替换为:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">\"古朋\"</span>,</span><br><span class=\"line\">  nick_name : <span class=\"string\">\"gupeng\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *这里将x对象赋值到当前局部变量中，减少不必要的指针路径解析运算</span></span><br><span class=\"line\"><span class=\"comment\"> *一般用于在在方法中将this对象局部化，比如：var this_ = this;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x_ = x;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x_.name+<span class=\"string\">'的小名是'</span>+x_nick_name);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>with这种语法现如今应该已经无人问津了，但是还是想来说说这个在JavaScript中的用法和缺点</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>with语句的作用是将代码的作用域设置到一个特定的对象中。</p>\n<p>利：with语句可以在不造成性能损失的情况下，减少变量的长度。很多情况下，也可以不使用with语句，而是使用一个临时变量来保存指针，来达到同样的效果。</p>\n<p>弊：with语句使得程序在查找该语句块中的所有的变量值时，都是先在该with语句指定的对象下面先寻找一遍，然后再去外面的作用域去寻找。所以尽量不要在该语句块中去使用一些不属于该对象中的变量</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">\"古朋\"</span>,</span><br><span class=\"line\">  nick_name : <span class=\"string\">\"gupeng\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">with</span>(x)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name+<span class=\"string\">'的小名是'</span>+nick_name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以替换为:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = &#123;</span><br><span class=\"line\">  name : <span class=\"string\">\"古朋\"</span>,</span><br><span class=\"line\">  nick_name : <span class=\"string\">\"gupeng\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *这里将x对象赋值到当前局部变量中，减少不必要的指针路径解析运算</span></span><br><span class=\"line\"><span class=\"comment\"> *一般用于在在方法中将this对象局部化，比如：var this_ = this;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x_ = x;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x_.name+<span class=\"string\">'的小名是'</span>+x_nick_name);</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[{"_id":"source/_posts/github页面连接域名/post-bg-2015.jpg","slug":"post-bg-2015.jpg","post":"cji2oynrj0001scuutgwmlgxj","modified":1,"renderable":0},{"_id":"source/_posts/with/post-bg-2015.jpg","slug":"post-bg-2015.jpg","post":"cji2oynrt0008scuusk4t3ivm","modified":1,"renderable":0},{"_id":"source/_posts/ZenCoding/post-bg-js-module.jpg","post":"cji2oynrq0006scuuc09yhl5t","slug":"post-bg-js-module.jpg","modified":1,"renderable":1},{"_id":"source/_posts/with/post-bg-js-module.jpg","post":"cji2oynrt0008scuusk4t3ivm","slug":"post-bg-js-module.jpg","modified":1,"renderable":1},{"_id":"source/_posts/with/post-bg-unix-linux.jpg","post":"cji2oynrt0008scuusk4t3ivm","slug":"post-bg-unix-linux.jpg","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cji2oynrj0001scuutgwmlgxj","tag_id":"cji2oynrp0005scuu0dk0iecs","_id":"cji2oynru000ascuudnhn790c"},{"post_id":"cji2oynrn0003scuuwoihkro0","tag_id":"cji2oynru0009scuuvsythpir","_id":"cji2oynrw000dscuuor9lqjpf"},{"post_id":"cji2oynrn0003scuuwoihkro0","tag_id":"cji2oynrv000bscuu3924btxt","_id":"cji2oynrw000escuuuh4j1oia"},{"post_id":"cji2oynrq0006scuuc09yhl5t","tag_id":"cji2oynru0009scuuvsythpir","_id":"cji2oynrx000hscuuyc33kz2k"},{"post_id":"cji2oynrq0006scuuc09yhl5t","tag_id":"cji2oynrv000bscuu3924btxt","_id":"cji2oynry000iscuuq1kluxt1"},{"post_id":"cji2oynrs0007scuul5ndnd7s","tag_id":"cji2oynru0009scuuvsythpir","_id":"cji2oynrz000lscuu6kxrx5df"},{"post_id":"cji2oynrs0007scuul5ndnd7s","tag_id":"cji2oynrv000bscuu3924btxt","_id":"cji2oynrz000mscuu7az6k0l9"},{"post_id":"cji2oynrt0008scuusk4t3ivm","tag_id":"cji2oynru0009scuuvsythpir","_id":"cji2oyns0000oscuunzi5l7ug"},{"post_id":"cji2oynrt0008scuusk4t3ivm","tag_id":"cji2oynrv000bscuu3924btxt","_id":"cji2oyns0000pscuuny0uzt4o"}],"Tag":[{"name":"github","_id":"cji2oynrp0005scuu0dk0iecs"},{"name":"前端开发","_id":"cji2oynru0009scuuvsythpir"},{"name":"JavaScript","_id":"cji2oynrv000bscuu3924btxt"}]}}